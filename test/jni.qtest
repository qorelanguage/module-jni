#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires jni
%requires QUnit
%requires Util

#%module-cmd(jni) add-relative-classpath java/bin
%module-cmd(jni) add-relative-classpath qore-jni-test.jar
%module-cmd(jni) import java.lang.reflect.*
%module-cmd(jni) import java.lang.invoke.*
%module-cmd(jni) import org.qore.jni.test.Fields
%module-cmd(jni) import org.qore.jni.test.QoreJavaApiTest
#%module-cmd(jni) import java.time.ZonedDateTime

%exec-class Main

class DtorThrows {
    destructor() {
        throw "DTOR-ERROR";
    }
    dummy() {
    }
}

class MyFields inherits Fields {
    any memberGate(string str) {
        return Fields::memberGate(str, True);
    }
}

class TestClass {
    public {
        string member = "mem";
    }

    string getString(string str = "default") {
        return str + "-x";
    }

    list<hash<auto>> getListOfHashes() {
        return (
            {
                "a": 1,
                "b": "two",
            },
            {
                "a": 3,
                "b": "four",
            },
        );
    }
}

class TestClass2 {
    public {
        static int cnt = 0;
    }

    destructor() {
        ++cnt;
    }

    string getString(string str = "default") {
        return str + "-y";
    }
}

TestClass sub get_object() {
    return new TestClass();
}

public class Main inherits QUnit::Test {
    public {
        const TestClass1ByteCode = <cafebabe0000003400110a0004000d08000e07000f0700100100063c696e69743e010003282956010004436f646501000f4c696e654e756d6265725461626c6501000367657401001428294c6a6176612f6c616e672f537472696e673b01000a536f7572636546696c65010009546573742e6a6176610c0005000601000474657374010004546573740100106a6176612f6c616e672f4f626a656374002000030004000000000002000000050006000100070000001d00010001000000052ab70001b10000000100080000000600010000000100000009000a000100070000001b00010001000000031202b0000000010008000000060001000000030001000b00000002000c>;

        const TestClass2ByteCode = <cafebabe0000003400110a0004000d08000e07000f0700100100063c696e69743e010003282956010004436f646501000f4c696e654e756d6265725461626c6501000367657401001428294c6a6176612f6c616e672f537472696e673b01000a536f7572636546696c6501000a54657374322e6a6176610c00050006010005546573743201000d6d792f746573742f54657374320100106a6176612f6c616e672f4f626a656374002000030004000000000002000000050006000100070000001d00010001000000052ab70001b10000000100080000000600010000000300000009000a000100070000001b00010001000000031202b0000000010008000000060001000000050001000b00000002000c>;
    }

    constructor() : Test("jni test", "1.0") {
        addTestCase("hash map test", \hashMapTest());
        addTestCase("number test", \numberTest());
        addTestCase("object test", \objectTest());
        addTestCase("date test", \dateTest());
        addTestCase("defineClass", \defineClassTest());
        addTestCase("issue 2950", \issue2950());
        addTestCase("class test", \testJniClasses());
        addTestCase("static method invocation test", \testStaticMethods());
        addTestCase("instance method invocation test", \testInstanceMethods());
        addTestCase("float conversion test", \testFloatConversions());
        addTestCase("static fields access test", \testStaticFields());
        addTestCase("instance fields access test", \testInstanceFields());
        addTestCase("callback test", \testCallback());
        addTestCase("constructor test", \testConstructor());
        addTestCase("string test", \testString());
        addTestCase("array test", \testArray());
        addTestCase("dispatcher destructor throws a Qore exception", \testDispatchDtorThrows());
        addTestCase("callback return value test", \testCallbackRetVal());
        addTestCase("special conversions test", \testSpecialConversions());
        addTestCase("api test", \testQoreJavaApi());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    hashMapTest() {
        {
            auto l = QoreJavaApiTest::testObject6();
            assertEq(Type::Hash, l[0].type());
        }

        hash<auto> h0 = {
            "a": 1,
            "b": "two",
        };

        {
            hash<auto> h1 = QoreJavaApiTest::testObject7(h0);
            assertEq(1, h1.size());
            assertEq(h0 - "a", h1);
        }

        {
            list<hash<auto>> l0= (
                h0,
                h0,
            );

            auto l1 = QoreJavaApiTest::testObject8(l0);
            assertEq(l0, l1);

            l1 = QoreJavaApiTest::testObject9(l0);
            assertEq(l0, l1);
        }

        {
            TestClass test();
            auto l = QoreJavaApiTest::testObject10(test);
            assertEq(test.getListOfHashes(), l);
        }
    }

    numberTest() {
        string num_str = M_PIn.toString();
        number val = QoreJavaApiTest::testObject5(num_str);
        # must convert to float
        assertNumberEq(M_PIn, val);
        assertNumberEq(M_PIn, QoreJavaApiTest::testObject5(M_PIn));
    }

    objectTest() {
        TestClass t();
        assertEq(True, QoreJavaApiTest::testObject4(t, "TestClass"));
        assertEq("test-x", QoreJavaApiTest::testObject1(t, "test"));
        assertEq("mem", QoreJavaApiTest::testObject2(t));
        assertEq(t, QoreJavaApiTest::testObject3(t));
        assertEq("TestClass", QoreJavaApiTest::testObject11(t));

        auto v = QoreJavaApiTest::testObject12();
        assertThrows("OBJECT-ALREADY-DELETED", \v.getString(), "str");
        v = QoreJavaApiTest::testObject13();
        assertEq("str-x", v.getString("str"));
        assertEq({"test": v}, get_thread_data("_jni_save"));
        hash<auto> td = remove_thread_data("_jni_save");
        assertEq({"test": v}, td._jni_save);
        remove td;
        remove v;
        v = QoreJavaApiTest::testObject12();
        assertThrows("OBJECT-ALREADY-DELETED", \v.getString(), "str");

        save_thread_data("_jni_save", "my-key");
        v = QoreJavaApiTest::testObject13();
        assertEq("str-x", v.getString("str"));
        assertEq({"test": v}, get_thread_data("my-key"));
        td = remove_thread_data("my-key");
        assertEq({"test": v}, td."my-key");
        remove td;
        remove v;
        v = QoreJavaApiTest::testObject12();
        assertThrows("OBJECT-ALREADY-DELETED", \v.getString(), "str");

        v = QoreJavaApiTest::testObject13();
        assertEq("str-x", v.getString("str"));
        assertEq({"test": v}, get_thread_data("my-key"));
        td = remove_thread_data("my-key");
        assertEq({"test": v}, td."my-key");
        remove td;
        remove v;
        v = QoreJavaApiTest::testObject12();
        assertThrows("OBJECT-ALREADY-DELETED", \v.getString(), "str");

        t = new TestClass();
        string val = QoreJavaApiTest::testObject14(t);
        assertEq("default-x", val);

        # test new object creation and saving a strong reference in a Java thread
        assertEq("default-y", QoreJavaApiTest::testObject15());
        # ensure that thread-local data created from Java threads is destroyed when
        # the Java thread terminates
        assertEq(1, TestClass2::cnt);
    }

    dateTest() {
        date now = now_us();
        string date_str = now.format("YYYY-MM-DDTHH:mm:SS.xxZ");
        date d = ZonedDateTime::parse(new String(date_str));
        assertEq(now, d);

        d = QoreJavaApiTest::dateTest(now);
        assertEq(now - 2D, d);
    }

    defineClassTest() {
        assertThrows("JNI-ERROR", \jni::define_class(), ("test", <abcd>));

        # issue #3023: create class from bytecode
        lang::Class jcls = define_class("Test", TestClass1ByteCode);
        assertEq("Test", jcls.getName());
        # create object from dynamically-created class
        object obj = jcls.newInstance();
        # test method call
        assertEq("test", obj.get());

        {
            Program p(PO_NEW_STYLE);
            p.issueModuleCmd("jni", "define-class my/test/Test2 " + TestClass2ByteCode.toBase64());
            #p.parse("%requires reflection\nlist<auto> sub test() { return Class::findAllRegex('Test2'); }", "");
            #map printf("%y\n", $1.getPathName()), p.callFunction("test");
            p.parse("Test2 sub test() { return new Test2(); }", "");
            obj = p.callFunction("test");
            assertEq("Test2", obj.get());
        }
    }

    issue2950() {
        int i = 0;
        Program p(PO_NEW_STYLE);
        p.parse("list<auto> sub get_closure() {
    Counter c(1);
    return (sub (Method m, *list args) { }, c);
}
        ", "");

        (code closure1, Counter c) = p.callFunction("get_closure");
        delete p;

        code closure2 = sub(Method m, *list args) { ++i; c.dec(); };

        QoreInvocationHandler h1(closure1);
        QoreInvocationHandler h2(closure2);
        lang::Class runnableClass = load_class("java/lang/Runnable");
        QoreJavaApiTest::threadTest(implement_interface(h1, runnableClass), implement_interface(h2, runnableClass));
        c.waitForZero();
        assertEq(1, i);
    }

    testQoreJavaApi() {
        auto hm = QoreJavaApiTest::callFunctionTest();
        assertEq("hash<auto>", hm.fullType());
    }

    testJniClasses() {
        # get the Math class
        lang::Class mathClass = load_class("java/lang/Math");
        # get the Math.acos() static method
        reflect::Method acosMethod = mathClass.getDeclaredMethod("acos", Double::TYPE);

        # get the StringBuffer class
        lang::Class stringBufferClass = load_class("java/lang/StringBuffer");
        # get the StringBuffer constructor with no arguments
        Constructor stringBufferConstructor = stringBufferClass.getConstructor();
        # get StringBuffer.append(double)
        reflect::Method appendDoubleMethod = stringBufferClass.getDeclaredMethod("append", Double::TYPE);
        # get StringBuffer.toString()
        reflect::Method toStringMethod = stringBufferClass.getDeclaredMethod("toString");
        # create a StringBuffer object
        Object buf = stringBufferConstructor.newInstance(());

        # write to our buffer
        appendDoubleMethod.invoke(buf, 1.0);
        appendDoubleMethod.invoke(buf, new Double(1.0));
        appendDoubleMethod.invoke(buf, acosMethod.invoke(NOTHING, new Double(-1.0)));
        appendDoubleMethod.invoke(buf, acosMethod.invoke(NOTHING, -1.0));

        assertEq("1.01.03.1415926535897933.141592653589793", toStringMethod.invoke(buf));
    }

    testStaticMethods() {
        lang::Class clazz = load_class("org/qore/jni/test/StaticMethods");

        # the purpose is to test all possible argument and return value types
        Method set = clazz.getDeclaredMethod("set", Integer::TYPE);
        Method get = clazz.getDeclaredMethod("get");                                       # overloaded
        Method cmp = clazz.getDeclaredMethod("cmp", (Short::TYPE, Long::TYPE));
        Method add = clazz.getDeclaredMethod("add", (Byte::TYPE, Character::TYPE));
        Method get2 = clazz.getDeclaredMethod("get", Boolean::TYPE);                    # overloaded
        Method avg = clazz.getDeclaredMethod("avg", (Byte::TYPE, Byte::TYPE, Byte::TYPE)); # overloaded
        Method max = clazz.getDeclaredMethod("max", (Long::TYPE, Long::TYPE));
        Method avg2 = clazz.getDeclaredMethod("avg", (Float::TYPE, Float::TYPE));          # overloaded
        Method avg3 = clazz.getDeclaredMethod("avg", (Double::TYPE, Double::TYPE));        # overloaded
        Method wrap = clazz.getDeclaredMethod("wrap", Integer::TYPE);
        Method unwrap = clazz.getDeclaredMethod("unwrap", load_class("java/lang/Integer"));
        Method getLongArray = clazz.getDeclaredMethod("getLongArray");
        Method useArray = clazz.getDeclaredMethod("useArray", load_class("[Ljava/lang/Object;"));

        # set() expects one argument
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", sub() { set.invoke(); });

        # get() expects no arguments
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", sub() { get.invoke(NOTHING, 123); });

        #assertThrows("JNI-ERROR", "?", sub() { get.invoke(123); });

        # cmp() expects two arguments
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", sub() { cmp.invoke(NOTHING, 1); });
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", sub() { cmp.invoke(NOTHING, (1, 2, 3)); });

        # set() has no retval, we test the side effect below using get()
        set.invoke(NOTHING, 42);

        # get() returns the value previously passed to set()
        assertEq(42, get.invoke());

        # cmp() 'converts' first arg to short and returns true if it is greater than the second argument
        assertTrue(cmp.invoke(NOTHING, (new Short(1000), new Long(-1234567890123))));
        assertTrue(cmp.invoke(NOTHING, (new Short(32767), new Long(1))));
        assertFalse(cmp.invoke(NOTHING, (new Short(32768), new Long(1))));  #the first argument overflows to -32768, which is not greater than 1

        # add() 'converts' first arg to byte (signed 8bit), second arg to char (unsigned 16bit) and adds them together
        assertEq(32768, add.invoke(NOTHING, (new Byte(1), new Character(32767))));
        assertEq(0, add.invoke(NOTHING, (new Byte(36), new Character(65500))));
        assertEq(65530, add.invoke(NOTHING, (new Byte(-5), new Character(-1))));      #-1 is 65535
        assertEq(999, add.invoke(NOTHING, (new Byte(255), new Character(1000))));     #255 is -1

        # get2() throws if called with true, otherwise returns 2^63-1
        assertThrows("JNI-ERROR", sub() { get2.invoke(NOTHING, True); });
        assertEq(0x7FFFFFFFFFFFFFFF, get2.invoke(NOTHING, False));

        # avg() 'converts' all args to byte and returns their average
        assertEq(2, avg.invoke(NOTHING, (new Byte(1), new Byte(2), new Byte(3))));
        assertEq(85, avg.invoke(NOTHING, (new Byte(126), new Byte(2), new Byte(127))));
        assertEq(-43, avg.invoke(NOTHING, (new Byte(128), new Byte(256), new Byte(-1))));  #128 -> -128, 256 -> 0

        # max() compares the arguments, converts the larger to short and returns it
        assertEq(10, max.invoke(NOTHING, (10, -4)));
        assertEq(-1, max.invoke(NOTHING, (65535, 0)));
        assertEq(-32768, max.invoke(NOTHING, (32768, 32768)));

        # avg2() 'converts' all args to float and returns their average
        assertFloatEq(2.92, avg2.invoke(NOTHING, (new Float(3.14), new Float(2.7))), 0.0000001);

        # avg3() returns the average of its arguments
        assertFloatEq(2.92, avg3.invoke(NOTHING, (3.14, 2.7)), 0.00000000000000001);

        # wrap() & unwrap()
        assertEq(42, wrap.invoke(NOTHING, 42));
        assertEq(42, unwrap.invoke(NOTHING, new Integer(42)));
        assertEq(-123, unwrap.invoke(NOTHING, (NOTHING,)));
        assertThrows("JNI-ERROR", sub() { unwrap.invoke(NOTHING, True); });
        assertThrows("JNI-ERROR", sub() { unwrap.invoke(self); });

        Integer i(10);
        Integer i2 = i;
        delete i2;
        assertThrows("OBJECT-ALREADY-DELETED", sub() { i.hashCode(); });

        # arrays
        list longArray = getLongArray.invoke();
        useArray.invoke(NOTHING, (longArray,));
    }

    testInstanceMethods() {
        lang::Class clsMethods = load_class("org/qore/jni/test/Methods");
        lang::Class clsA = load_class("org/qore/jni/test/A");
        lang::Class clsB = load_class("org/qore/jni/test/B");
        lang::Class clsC = load_class("org/qore/jni/test/C");

        Object c = clsMethods.getDeclaredField("c").get(NOTHING);
        Object b = clsMethods.getDeclaredField("b").get(NOTHING);

        reflect::Method fInA = clsA.getDeclaredMethod("f");
        reflect::Method fInB = clsB.getDeclaredMethod("f");
        reflect::Method fInC = clsC.getDeclaredMethod("f");
        reflect::Method mInC = clsC.getDeclaredMethod("m");

        # virtual dispatch
        assertEq(3, fInA.invoke(c));
        assertEq(3, fInB.invoke(c));
        assertEq(3, fInC.invoke(c));

        # non-virtual dispatch
        fInA.setAccessible(True);
        assertThrows("JNI-ERROR", "java.lang.IllegalAccessException", sub () { (MethodHandles::publicLookup()).findVirtual(clsA, "f", MethodType::methodType(Integer::TYPE)); });
        MethodHandle handle = MethodHandles::publicLookup().unreflect(fInA);
        assertThrows("JNI-ERROR", "java.lang.UnsupportedOperationException", sub () { handle.invokeExact(c); });

        assertEq(1, invoke_nonvirtual(fInA, c));
        assertEq(2, invoke_nonvirtual(fInB, c));
        assertEq(3, invoke_nonvirtual(fInC, c));

        # class mismatch
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", sub() { mInC.invoke(b); });
        assertThrows("JNI-ERROR", sub() { invoke_nonvirtual(mInC, b); });
    }

    testFloatConversions() {
        lang::Class clazz = load_class("org/qore/jni/test/FloatConversions");

        assertTrue(clazz.getDeclaredMethod("isNaNFloat", Float::TYPE).invoke(NOTHING, new Float(@NaN@)));
        assertTrue(clazz.getDeclaredMethod("isNInfFloat", Float::TYPE).invoke(NOTHING, new Float(-@Inf@)));
        assertTrue(clazz.getDeclaredMethod("isPInfFloat", Float::TYPE).invoke(NOTHING, new Float(@Inf@)));
        assertTrue(clazz.getDeclaredMethod("getNaNFloat").invoke().nanp());
        assertEq(-@Inf@, clazz.getDeclaredMethod("getNInfFloat").invoke());
        assertEq(@Inf@, clazz.getDeclaredMethod("getPInfFloat").invoke());

        assertTrue(clazz.getDeclaredMethod("isNaNDouble", Double::TYPE).invoke(NOTHING, @NaN@));
        assertTrue(clazz.getDeclaredMethod("isNInfDouble", Double::TYPE).invoke(NOTHING, -@Inf@));
        assertTrue(clazz.getDeclaredMethod("isPInfDouble", Double::TYPE).invoke(NOTHING, @Inf@));
        assertTrue(clazz.getDeclaredMethod("getNaNDouble").invoke().nanp());
        assertEq(-@Inf@, clazz.getDeclaredMethod("getNInfDouble").invoke());
        assertEq(@Inf@, clazz.getDeclaredMethod("getPInfDouble").invoke());
    }

    testStaticFields() {
        lang::Class clazz = load_class("org/qore/jni/test/StaticFields");

        Field z = clazz.getDeclaredField("z");
        Field b = clazz.getDeclaredField("b");
        Field c = clazz.getDeclaredField("c");
        Field s = clazz.getDeclaredField("s");
        Field i = clazz.getDeclaredField("i");
        Field j = clazz.getDeclaredField("j");
        Field f = clazz.getDeclaredField("f");
        Field d = clazz.getDeclaredField("d");
        Field n = clazz.getDeclaredField("n");
        Field l = clazz.getDeclaredField("l");
        Field ba = clazz.getDeclaredField("ba");
        Field o = clazz.getDeclaredField("o");
        Field oa = clazz.getDeclaredField("oa");
        Field ia = clazz.getDeclaredField("ia");

        z.set(NOTHING, True);
        assertTrue(z.get());

        b.set(NOTHING, new Byte(42));
        assertEq(42, b.get());

        c.set(NOTHING, new Character(32768));
        assertEq(32768, c.get());

        s.set(NOTHING, new Short(65535));
        assertEq(-1, s.get());

        i.set(NOTHING, 0x123456789);
        assertEq(0x23456789, i.get());

        j.set(NOTHING, new Long(0x123456789));
        assertEq(0x123456789, j.get());

        f.set(NOTHING, new Float(3.14));
        assertFloatEq(3.14, f.get(), 0.0001);
        f.set(NOTHING, new Float(@NaN@));
        assertTrue(f.get().nanp());

        d.set(NOTHING, 2.7);
        assertFloatEq(2.7, d.get(), 0.0000001);
        d.set(NOTHING, @Inf@);
        assertTrue(d.get().infp());

        int myint = clazz.getDeclaredMethod("wrap", Integer::TYPE).invoke(NOTHING, (42, ));
        n.set(NOTHING, myint);
        assertEq(42, clazz.getDeclaredMethod("unwrapN").invoke());

        assertThrows("JNI-ERROR", sub(){ l.set(NOTHING, myint); });
        assertEq(NOTHING, l.get());

        list byteArray = ba.get();
        list objectArray = oa.get();
        list intArray = ia.get();

        o.set(NOTHING, byteArray);                                               # arrays in Java are Objects
        # byte[] is not a subtype of Object[], but a list of ints is converted to int[]
        oa.set(NOTHING, byteArray);
        oa.set(NOTHING, intArray);                                               # arrays in Java are covariant
        assertThrows("JNI-ERROR", sub() { ia.set(NOTHING, objectArray); });      # Object[] is not a subtype of Integer[]
        assertThrows("JNI-ERROR", sub() { n.set(NOTHING, byteArray); });         # byte[] is not a Number
        assertThrows("JNI-ERROR", sub() { ba.set(NOTHING, myint); });            # Integer is not a byte[]

        o.set(NOTHING, clazz);                                                   # classes are objects, too
    }

    testInstanceFields() {
        lang::Class clazz = load_class("org/qore/jni/test/Fields");

        Object instance = clazz.getDeclaredField("instance").get();

        Field z = clazz.getDeclaredField("z");
        Field b = clazz.getDeclaredField("b");
        Field c = clazz.getDeclaredField("c");
        Field s = clazz.getDeclaredField("s");
        Field i = clazz.getDeclaredField("i");
        Field j = clazz.getDeclaredField("j");
        Field f = clazz.getDeclaredField("f");
        Field d = clazz.getDeclaredField("d");
        Field ba = clazz.getDeclaredField("ba");
        Field o = clazz.getDeclaredField("o");
        Field oa = clazz.getDeclaredField("oa");
        Field ia = clazz.getDeclaredField("ia");

        z.set(instance, True);
        assertTrue(z.get(instance));

        b.set(instance, new Byte(42));
        assertEq(42, b.get(instance));

        c.set(instance, new Character(32768));
        assertEq(32768, c.get(instance));

        s.set(instance, new Short(65535));
        assertEq(-1, s.get(instance));

        i.set(instance, 0x123456789);
        assertEq(0x23456789, i.get(instance));

        j.set(instance, new Long(0x123456789));
        assertEq(0x123456789, j.get(instance));

        f.set(instance, new Float(3.14));
        assertFloatEq(3.14, f.get(instance), 0.0001);
        f.set(instance, new Float(@NaN@));
        assertTrue(f.get(instance).nanp());

        d.set(instance, 2.7);
        assertFloatEq(2.7, d.get(instance), 0.0000001);
        d.set(instance, @Inf@);
        assertTrue(d.get(instance).infp());

        list byteArray = ba.get(instance);
        list objectArray = oa.get(instance);
        list intArray = ia.get(instance);

        o.set(instance, byteArray);                                             # arrays in Java are Objects
        # byte[] is not a subtype of Object[], but a list of ints is converted to int[]
        oa.set(instance, byteArray);
        oa.set(instance, intArray);                                             # arrays in Java are covariant
        assertThrows("JNI-ERROR", sub() { ia.set(instance, objectArray); });    # Object[] is not a subtype of Integer[]

        o.set(instance, clazz);                                                 # classes are objects, too

        assertThrows("JNI-ERROR", sub() { z.set(byteArray, True); });

        # test Qore explicit Field access
        assertEq((0, 0, 0), instance.ba);
        assertEq((NOTHING, NOTHING, NOTHING), instance.oa);
        assertEq((NOTHING, NOTHING, NOTHING), instance.ia);

        # Qore's access protection is triggered here
        assertThrows("PRIVATE-MEMBER", sub () { delete instance.z;});
        # here the builtin methodGate method is called
        assertThrows("JNI-ACCESS-ERROR", sub () { any bl = instance.z; delete bl; });
        # Qore's access protection is triggered here
        assertThrows("PRIVATE-MEMBER", sub () { delete instance.pi;});
        # here the builtin methodGate method is called
        assertThrows("JNI-ACCESS-ERROR", sub () { any bl = instance.pi; delete bl; });

        MyFields mf();
        assertEq(1, mf.pi);
    }

    testCallback() {
        int i = 1;
        QoreInvocationHandler h(sub(Method m, *list args) { if (++i > 3) throw "CALLBACK-ERROR";});
        assertEq("org.qore.jni.QoreInvocationHandler", h.getClass().getCanonicalName());

        lang::Class runnableClass = load_class("java/lang/Runnable");
        Object o = implement_interface(h, runnableClass);
        lang::Class clazz = load_class("org/qore/jni/test/Callbacks");
        Method callNow = clazz.getDeclaredMethod("callNow", (runnableClass, ));
        Method callInThread = clazz.getDeclaredMethod("callInThread", (runnableClass, ));
        Method trueIfThrows = clazz.getDeclaredMethod("trueIfThrows", (runnableClass, ));
        Method doThrow = clazz.getDeclaredMethod("doThrow");
        callNow.invoke(NOTHING, o);
        assertEq(2, i);
        callInThread.invoke(NOTHING, o);
        usleep(200ms);
        assertEq(3, i);
        try {
            callNow.invoke(NOTHING, o);
            assertEq(False, True);
        }
        catch (hash ex) {
            assertEq(ex.err, "JNI-ERROR");
            assertEq(True, ex.desc =~ /java.lang.reflect.InvocationTargetException/);
            assertEq("CALLBACK-ERROR", ex.arg.getTargetException().getMessage());
        }
        assertThrows("CALLBACK-ERROR", \invoke(), (callNow, NOTHING, o));
        assertThrows("CALLBACK-ERROR", \invoke_nonvirtual(), (callNow, NOTHING, o));
        try {
            doThrow.invoke();
            assertEq(False, True);
        }
        catch (hash ex) {
            assertEq(True, ex.callstack[0].file =~ /\.java$/);
        }
        h.destroy();

        doThrow.setAccessible(True);
        trueIfThrows.setAccessible(True);
        h = new QoreInvocationHandler(sub(Method m, *list args) { doThrow.invoke(NOTHING); });
        assertTrue(trueIfThrows.invoke(NOTHING, implement_interface(h, runnableClass)));
        h.destroy();
    }

    testConstructor() {
        lang::Class cls = load_class("java/lang/Integer");
        Constructor ctor = cls.getConstructor(Integer::TYPE);
        int i = ctor.newInstance(42);
        assertEq(42, cls.getDeclaredMethod("intValue").invoke(i));
    }

    testString() {
        lang::Class cls = load_class("java/lang/Integer");
        int i = cls.getMethod("valueOf", load_class("java/lang/String")).invoke(NOTHING, "42");
        assertEq(42, cls.getMethod("intValue").invoke(i));

        i = cls.getConstructor(Integer::TYPE).newInstance(123);
        assertEq("123", cls.getMethod("toString").invoke(i));
    }

    testArray() {
        JavaArray a = new_array(Boolean::TYPE, 3);
        # get java class name
        assertEq("boolean[]", a.getClass().getCanonicalName());
        # get internal class name
        assertEq("[Z", a.getClass().getName());
        # get Qore class name
        assertEq("JavaArray", a.className());
        a.set(0, True);
        assertThrows("JNI-ERROR", sub() { a.set(3, True); });
        assertEq(3, a.length());
        assertTrue(a.get(0));
        assertFalse(a.get(1));

        a = new_array(Byte::TYPE, 4);
        a.set(0, 127);
        a.set(2, -128);
        a.set(3, 257);
        assertThrows("JNI-ERROR", sub() { a.get(4); });
        assertEq(127, a.get(0));
        assertEq(0, a.get(1));
        assertEq(-128, a.get(2));
        assertEq(1, a.get(3));

        a = new_array(Character::TYPE, 4);
        a.set(0, 65535);
        a.set(2, -1);
        a.set(3, 65537);
        assertEq(65535, a.get(0));
        assertEq(0, a.get(1));
        assertEq(65535, a.get(2));
        assertEq(1, a.get(3));

        a = new_array(Short::TYPE, 4);
        a.set(0, 32767);
        a.set(2, -32768);
        a.set(3, 65537);
        assertEq(32767, a.get(0));
        assertEq(0, a.get(1));
        assertEq(-32768, a.get(2));
        assertEq(1, a.get(3));

        a = new_array(Integer::TYPE, 4);
        a.set(0, 2147483647);
        a.set(2, -2147483648);
        a.set(3, 0x100000001);
        assertEq(2147483647, a.get(0));
        assertEq(0, a.get(1));
        assertEq(-2147483648, a.get(2));
        assertEq(1, a.get(3));

        a = new_array(Long::TYPE, 4);
        a.set(0, 9223372036854775807);
        a.set(2, -9223372036854775807 - 1);
        assertEq(9223372036854775807, a.get(0));
        assertEq(0, a.get(1));
        assertEq(-9223372036854775807 - 1, a.get(2));

        a = new_array(Float::TYPE, 4);
        a.set(0, 3.14);
        a.set(2, @NaN@);
        a.set(3, -@Inf@);
        assertFloatEq(3.14, a.get(0), 0.00001);
        assertFloatEq(0, a.get(1), 0.00001);
        assertTrue(a.get(2).nanp());
        assertTrue(a.get(3) < 0 && a.get(3).infp());

        a = new_array(Double::TYPE, 4);
        a.set(0, 3.14);
        a.set(2, @NaN@);
        a.set(3, -@Inf@);
        assertFloatEq(3.14, a.get(0), 0.00000000001);
        assertFloatEq(0, a.get(1), 0.00000000001);
        assertTrue(a.get(2).nanp());
        assertTrue(a.get(3) < 0 && a.get(3).infp());

        a = new_array(load_class("java/lang/String"), 4);
        a.set(0, "Hello, world!");
        a.set(2, NOTHING);
        assertThrows("JNI-ERROR", sub() { a.set(3, a); });
        assertEq("Hello, world!", a.get(0));
        assertEq(NOTHING, a.get(1));
        assertEq(NOTHING, a.get(2));

        #two-dimensional int array
        a = new_array(load_class("[I"), 2);
        a.set(0, (1, 2));
        a.set(1, (3, 4));
        assertEq(1, a.get(0)[0]);
        assertEq(2, a.get(0)[1]);
        assertEq(3, a.get(1)[0]);
        assertEq(4, a.get(1)[1]);
        /*
        a.set(0, new_array(Integer::TYPE, 2));
        a.set(1, new_array(Integer::TYPE, 2));
        a.get(0).set(0, 1);
        a.get(0).set(1, 2);
        a.get(1).set(0, 3);
        a.get(1).set(1, 4);
        assertEq(1, a.get(0).get(0));
        assertEq(2, a.get(0).get(1));
        assertEq(3, a.get(1).get(0));
        assertEq(4, a.get(1).get(1));
        */
    }

    testDispatchDtorThrows() {
        QoreInvocationHandler h;
        {
            DtorThrows instance();
            h = new QoreInvocationHandler(sub(Method m, *list args) { instance.dummy(); });
        }
        assertThrows("DTOR-ERROR", sub() { h.destroy(); });
    }

    testCallbackRetVal() {
        QoreInvocationHandler h(any sub(Method m, *list args) { return "STR"; });
        lang::Class stringFactoryClass = load_class("org/qore/jni/test/StringFactory");
        Object f = implement_interface(h, stringFactoryClass);
        lang::Class clazz = load_class("org/qore/jni/test/Callbacks");
        Method createString = clazz.getDeclaredMethod("createString", stringFactoryClass);
        assertEq("*STR*", createString.invoke(NOTHING, f));
    }

    testSpecialConversions() {
        reflect::Method m = load_class("org/qore/jni/test/StaticMethods").getDeclaredMethod("conversions", load_class("java/lang/String"));
        assertEq(NOTHING, m.invoke(NOTHING, ""));

        auto o = m.invoke(NOTHING, "method");
        assertTrue(o instanceof Method);
        assertEq("42", o.invoke(load_class("java/lang/Integer").getConstructor(Integer::TYPE).newInstance(42)));

        o = m.invoke(NOTHING, "static method");
        assertTrue(o instanceof Method);
        assertEq("42", load_class("java/lang/Integer").getMethod("toString").invoke(o.invoke(NOTHING, 42)));

        o = m.invoke(NOTHING, "constructor");
        assertTrue(o instanceof Constructor);
        assertEq("42", load_class("java/lang/Integer").getMethod("toString").invoke(o.newInstance(42)));

        lang::Class fieldsClass = load_class("org/qore/jni/test/Fields");
        Object fieldsInstance = fieldsClass.getDeclaredField("instance").get();

        o = m.invoke(NOTHING, "field");
        assertTrue(o instanceof Field);
        o.set(fieldsInstance, 123);
        assertEq(123, fieldsClass.getDeclaredField("i").get(fieldsInstance));

        o = m.invoke(NOTHING, "static field");
        assertTrue(o instanceof Field);
        o.set(NOTHING, 456);
        assertThrows("JNI-ERROR", "java.lang.IllegalArgumentException", \o.set());
        assertEq(456, load_class("org/qore/jni/test/StaticFields").getDeclaredField("i").get());
    }
}
